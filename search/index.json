[{"content":"语义化版本 2.0.0 摘要 版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n简介 在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。\n在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你项目的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。\n作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可能包括文档或代码的强制要求。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。\n我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。\n语义化版本控制规范（SemVer） 以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。\n使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。\n标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0。\n标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。\n主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。\n1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。\n修订号 Z（x.y.Z | x \u0026gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n次版本号 Y（x.Y.z | x \u0026gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。\n主版本号 X（X.y.z | X \u0026gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。\n先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n版本的优先层级指的是不同版本在排序时如何比较。\n判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。\n由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。\n例如：1.0.0 \u0026lt; 2.0.0 \u0026lt; 2.1.0 \u0026lt; 2.1.1。\n当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。\n例如：1.0.0-alpha \u0026lt; 1.0.0。\n有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：\n只有数字的标识符以数值高低比较。\n有字母或连接号时则逐字以 ASCII 的排序来比较。\n数字的标识符比非数字的标识符优先层级低。\n若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。\n例如：1.0.0-alpha \u0026lt; 1.0.0-alpha.1 \u0026lt; 1.0.0-alpha.beta \u0026lt; 1.0.0-beta \u0026lt; 1.0.0-beta.2 \u0026lt; 1.0.0-beta.11 \u0026lt; 1.0.0-rc.1 \u0026lt; 1.0.0。\n合法语义化版本的巴科斯范式语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 \u0026lt;valid semver\u0026gt; ::= \u0026lt;version core\u0026gt; | \u0026lt;version core\u0026gt; \u0026#34;-\u0026#34; \u0026lt;pre-release\u0026gt; | \u0026lt;version core\u0026gt; \u0026#34;+\u0026#34; \u0026lt;build\u0026gt; | \u0026lt;version core\u0026gt; \u0026#34;-\u0026#34; \u0026lt;pre-release\u0026gt; \u0026#34;+\u0026#34; \u0026lt;build\u0026gt; \u0026lt;version core\u0026gt; ::= \u0026lt;major\u0026gt; \u0026#34;.\u0026#34; \u0026lt;minor\u0026gt; \u0026#34;.\u0026#34; \u0026lt;patch\u0026gt; \u0026lt;major\u0026gt; ::= \u0026lt;numeric identifier\u0026gt; \u0026lt;minor\u0026gt; ::= \u0026lt;numeric identifier\u0026gt; \u0026lt;patch\u0026gt; ::= \u0026lt;numeric identifier\u0026gt; \u0026lt;pre-release\u0026gt; ::= \u0026lt;dot-separated pre-release identifiers\u0026gt; \u0026lt;dot-separated pre-release identifiers\u0026gt; ::= \u0026lt;pre-release identifier\u0026gt; | \u0026lt;pre-release identifier\u0026gt; \u0026#34;.\u0026#34; \u0026lt;dot-separated pre-release identifiers\u0026gt; \u0026lt;build\u0026gt; ::= \u0026lt;dot-separated build identifiers\u0026gt; \u0026lt;dot-separated build identifiers\u0026gt; ::= \u0026lt;build identifier\u0026gt; | \u0026lt;build identifier\u0026gt; \u0026#34;.\u0026#34; \u0026lt;dot-separated build identifiers\u0026gt; \u0026lt;pre-release identifier\u0026gt; ::= \u0026lt;alphanumeric identifier\u0026gt; | \u0026lt;numeric identifier\u0026gt; \u0026lt;build identifier\u0026gt; ::= \u0026lt;alphanumeric identifier\u0026gt; | \u0026lt;digits\u0026gt; \u0026lt;alphanumeric identifier\u0026gt; ::= \u0026lt;non-digit\u0026gt; | \u0026lt;non-digit\u0026gt; \u0026lt;identifier characters\u0026gt; | \u0026lt;identifier characters\u0026gt; \u0026lt;non-digit\u0026gt; | \u0026lt;identifier characters\u0026gt; \u0026lt;non-digit\u0026gt; \u0026lt;identifier characters\u0026gt; \u0026lt;numeric identifier\u0026gt; ::= \u0026#34;0\u0026#34; | \u0026lt;positive digit\u0026gt; | \u0026lt;positive digit\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;identifier characters\u0026gt; ::= \u0026lt;identifier character\u0026gt; | \u0026lt;identifier character\u0026gt; \u0026lt;identifier characters\u0026gt; \u0026lt;identifier character\u0026gt; ::= \u0026lt;digit\u0026gt; | \u0026lt;non-digit\u0026gt; \u0026lt;non-digit\u0026gt; ::= \u0026lt;letter\u0026gt; | \u0026#34;-\u0026#34; \u0026lt;digits\u0026gt; ::= \u0026lt;digit\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;digit\u0026gt; ::= \u0026#34;0\u0026#34; | \u0026lt;positive digit\u0026gt; \u0026lt;positive digit\u0026gt; ::= \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; | \u0026#34;4\u0026#34; | \u0026#34;5\u0026#34; | \u0026#34;6\u0026#34; | \u0026#34;7\u0026#34; | \u0026#34;8\u0026#34; | \u0026#34;9\u0026#34; \u0026lt;letter\u0026gt; ::= \u0026#34;A\u0026#34; | \u0026#34;B\u0026#34; | \u0026#34;C\u0026#34; | \u0026#34;D\u0026#34; | \u0026#34;E\u0026#34; | \u0026#34;F\u0026#34; | \u0026#34;G\u0026#34; | \u0026#34;H\u0026#34; | \u0026#34;I\u0026#34; | \u0026#34;J\u0026#34; | \u0026#34;K\u0026#34; | \u0026#34;L\u0026#34; | \u0026#34;M\u0026#34; | \u0026#34;N\u0026#34; | \u0026#34;O\u0026#34; | \u0026#34;P\u0026#34; | \u0026#34;Q\u0026#34; | \u0026#34;R\u0026#34; | \u0026#34;S\u0026#34; | \u0026#34;T\u0026#34; | \u0026#34;U\u0026#34; | \u0026#34;V\u0026#34; | \u0026#34;W\u0026#34; | \u0026#34;X\u0026#34; | \u0026#34;Y\u0026#34; | \u0026#34;Z\u0026#34; | \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; | \u0026#34;d\u0026#34; | \u0026#34;e\u0026#34; | \u0026#34;f\u0026#34; | \u0026#34;g\u0026#34; | \u0026#34;h\u0026#34; | \u0026#34;i\u0026#34; | \u0026#34;j\u0026#34; | \u0026#34;k\u0026#34; | \u0026#34;l\u0026#34; | \u0026#34;m\u0026#34; | \u0026#34;n\u0026#34; | \u0026#34;o\u0026#34; | \u0026#34;p\u0026#34; | \u0026#34;q\u0026#34; | \u0026#34;r\u0026#34; | \u0026#34;s\u0026#34; | \u0026#34;t\u0026#34; | \u0026#34;u\u0026#34; | \u0026#34;v\u0026#34; | \u0026#34;w\u0026#34; | \u0026#34;x\u0026#34; | \u0026#34;y\u0026#34; | \u0026#34;z\u0026#34; 为什么要使用语义化的版本控制？ 这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。\n举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，你可以放心地指定依赖于梯子的版本号大于等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。\n作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。\n如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。\nFAQ 在 0.y.z 初始开发阶段，我该如何进行版本控制？ 最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。\n如何判断发布 1.0.0 版本的时机？ 当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。\n这不会阻碍快速开发和迭代吗？ 主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。\n对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？ 这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。\n为整个公共 API 写文档太费事了！ 为供他人使用的软件编写适当的文档，是你作为一名专业开发者应尽的职责。保持项目高效的一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。\n万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？ 一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。\n如果我更新了自己的依赖但没有改变公共 API 该怎么办？ 由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。\n如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中） 自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。\n我该如何处理即将弃用的功能？ 弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文档让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。\n语义化版本对于版本的字符串长度是否有限制呢？ 没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。再者，特定的系统对于字符串长度可能会有他们自己的限制。\n“v1.2.3” 是一个语义化版本号吗？ “v1.2.3” 并不是的一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。比如：git tag v1.2.3 -m \u0026quot;Release version 1.2.3\u0026quot; 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。\n是否有推荐的正则表达式用以检查语义化版本号的正确性？ 有两个推荐的正则表达式。第一个用于支持按组名称提取的语言（PCRE[Perl 兼容正则表达式，比如 Perl、PHP 和 R]、Python 和 Go）。\n参见：https://regex101.com/r/Ly7O1x/3/\n1 ^(?P\u0026lt;major\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;minor\u0026gt;0|[1-9]\\d*)\\.(?P\u0026lt;patch\u0026gt;0|[1-9]\\d*)(?:-(?P\u0026lt;prerelease\u0026gt;(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P\u0026lt;buildmetadata\u0026gt;[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ 第二个用于支持按编号提取的语言（与第一个对应的提取项按顺序分别为：major、minor、patch、prerelease、buildmetadata）。主要包括 ECMA Script（JavaScript）、PCRE（Perl 兼容正则表达式，比如 Perl、PHP 和 R）、Python 和 Go。 参见：https://regex101.com/r/vkijKf/1/\n1 ^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ 关于 语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。\n如果您有任何建议，请到 GitHub 上提出您的问题。\n许可证 知识共享 署名 3.0 (CC BY 3.0)\n","date":"2023-09-05T23:45:06+08:00","image":"https://ifcat.github.io/p/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC/cover_huc1dd60740e8030901c16d7545c3ee840_806028_120x120_fill_q75_box_smart1.jpg","permalink":"https://ifcat.github.io/p/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC/","title":"语义化版本"},{"content":"标题 级数 标题分为四级。\n一级标题：文章的标题 二级标题：文章主要部分的大标题 三级标题：二级标题下面一级的小标题 四级标题：三级标题下面某一方面的小标题 下面是示例。\n1 2 3 4 5 6 7 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 原则 （1）一级标题下，不能直接出现三级标题。\n示例：下面的文章结构，缺少二级标题。\n1 2 3 # 一级标题 ### 三级标题 （2）标题要避免孤立编号（即同级标题只有一个）。\n示例：下面的文章结构，二级标题 A只包含一个三级标题，完全可以省略三级标题 A。\n1 2 3 4 5 ## 二级标题 A ### 三级标题 A ## 二级标题 B （3）下级标题不重复上一级标题的名字。\n示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。\n1 2 3 ## 概述 ### 概述 （4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。\n如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。\n示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 结构一 ### 三级标题 #### 四级标题 A #### 四级标题 B #### 四级标题 C 结构二 ### 三级标题 **（1）A** **（2）B** **（3）C** 文本 字间距 （1）全角中文字符与半角英文字符之间，应有一个半角空格。\n1 2 3 错误：本文介绍如何快速启动Windows系统。 正确：本文介绍如何快速启动 Windows 系统。 （2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。\n1 2 3 正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。 正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。 半角的百分号，视同阿拉伯数字。\n1 2 3 正确：今年我国经济增长率是6.5%。 正确：今年我国经济增长率是 6.5%。 （3）英文单位若不翻译，单位前的阿拉伯数字与单位符号之间，应留出适当的空隙。\n1 2 3 例1：一部容量为 16 GB 的智能手机 例2：1 h = 60 min = 3,600 s （4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。\n1 2 3 错误：他的电脑是 MacBook Air 。 正确：他的电脑是 MacBook Air。 句子 （1）避免使用长句。\n不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。\n1 2 3 错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。 正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。 逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。\n（2）尽量使用简单句和并列句，避免使用复合句。\n1 2 3 并列句：他昨天生病了，没有参加会议。 复合句：那个昨天生病的人没有参加会议。 （3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。\n1 2 3 错误：请确认没有接通装置的电源。 正确：请确认装置的电源已关闭。 （4）避免使用双重否定句。\n1 2 3 错误：没有删除权限的用户，不能删除此文件。 正确：用户必须拥有删除权限，才能删除此文件。 写作风格 （1）尽量不使用被动语态，改为使用主动语态。\n1 2 3 错误：假如此软件尚未被安装， 正确：假如尚未安装这个软件， （2）不使用非正式的语言风格。\n1 2 3 错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！ 正确：无法参加本次活动，我深感遗憾。 （3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。\n1 2 3 错误：这是唯二的快速启动的方法。 正确：这是仅有的两种快速启动的方法。 （4）用对“的”、“地”、“得”。\n1 2 3 4 5 6 7 8 她露出了开心的笑容。 （形容词＋的＋名词） 她开心地笑了。 （副词＋地＋动词） 她笑得很开心。 （动词＋得＋副词） （5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。\n1 2 3 错误：从管理系统可以监视中继系统和受其直接控制的分配系统。 正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。 （6）名词前不要使用过多的形容词。\n1 2 3 错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。 正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。 英文处理 （1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。\n1 2 3 英文：...information stored in random access memory (RAMs)... 中文：⋯⋯存储在随机存取存储器（RAM）里的信息⋯⋯ （2）外文缩写可以使用半角圆点(.)表示缩写。\n1 2 U.S.A. Apple, Inc. （3）表示中文时，英文省略号（...）应改为中文省略号（⋯⋯）。\n1 2 3 英文：5 minutes later... 中文：5 分钟过去了⋯⋯ （4）英文书名或电影名改用中文表达时，双引号应改为书名号。\n1 2 3 英文：He published an article entitled \u0026#34;The Future of the Aviation\u0026#34;. 中文：他发表了一篇名为《航空业的未来》的文章。 （5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。\n1 IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。 （6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。\n1 2 3 “American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。 “online transaction processing”（在线事务处理）不是专有名词，不应大写。 段落 原则 一个段落只能有一个主题，或一个中心句子。 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为中心句子服务。 一个段落的长度不能超过七行，最佳段落长度小于等于四行。 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。 段落之间使用一个空行隔开。 段落开头不要留出空白字符。 引用 引用第三方内容时，应注明出处。\n1 One man’s constant is another man’s variable. — Alan Perlis 如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。\n1 本文转载自 WikiQuote 使用外部图片时，必须在图片下方或文末标明来源。\n1 本文部分图片来自 Wikipedia 数值 半角数字 阿拉伯数字一律使用半角形式，不得使用全角形式。\n1 2 3 错误：这件商品的价格是１０００元。 正确：这件商品的价格是 1000 元。 千分号 数值为千位以上，应添加千分号（半角逗号）。\n1 XXX 公司的实收资本为 ￥1,258,000 人民币。 对于 4 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于 4 位以上的数值，应添加千分号。\n货币 货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。\n1 2 $1,000 1,000 美元 英文的货币名称，建议参考国际标准 ISO 4217。\n数值范围 表示数值范围时，用波浪线（～）或一字线（—）连接。参见《标点符号》一节的“连接号”部分。\n带有单位或百分号时，两个数字建议都要加上单位或百分号。\n1 2 3 132 kg～234 kg 67%～89% 变化程度的表示法 数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。\n1 2 3 4 5 增加到过去的两倍 （过去为一，现在为二） 增加了两倍 （过去为一，现在为三） 数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。\n1 2 3 4 5 降低到百分之八十 （定额是一百，现在是八十） 降低了百分之八十 （原来是一百，现在是二十） 不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。\n标点符号 原则 （1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。\n（2）如果整句为英文，则该句使用英文/半角标点。\n（3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。\n（4）点号（句号、逗号、顿号、分号、冒号）不得出现在标题的末尾，而标号（引号、括号、破折号、省略号、书名号、着重号、间隔号、叹号、问号）可以。\n句号 （1）中文语句的结尾处应该用全角句号（。）。\n（2）句子末尾用括号加注时，句号应在括号之外。\n1 2 3 错误：关于文件的输出，请参照第 1.3 节（见第 26 页。） 正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。 逗号 （1）逗号（，）表示句子内部的一般性停顿。\n（2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。\n顿号 （1）句子内部的并列词，应该用全角顿号(、) 分隔，而不用逗号，即使并列词是英语也是如此。\n1 2 3 错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 （2）英文句子中，并列词语之间使用半角逗号（,）分隔。\n1 例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components. （3）中文句子内部的并列词，最后一个尽量使用（和）来连接，使句子读起来更加连贯，下面两个句子都可以，第二个更优。\n1 2 3 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里，以及百度等。 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 分号 （1）分号（；）表示复句内部并列分句之间的停顿。\n引号 （1）引用时，应该使用全角双引号（“ ”），注意前后双引号不同。\n1 例句：许多人都认为客户服务的核心是“友好”和“专业”。 （2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（‘ ’），注意前后单引号不同。\n1 例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。” 括号 （1）补充说明时，使用全角圆括号（（）），括号前后不加空格。\n1 例句：请确认所有的连接（电缆和接插件）均安装牢固。 （2）几种括号的中英文名称。\n英文 中文 { } braces 或 curly brackets 大括号 [ ] square brackets 或 brackets 方括号 \u0026lt; \u0026gt; angled brackets 尖括号 ( ) parentheses 圆括号 冒号 （1）全角冒号（：）常用在需要解释的词语后边，引出解释和说明。\n1 例句：请确认以下几项内容：时间、地点、活动名称和来宾数量。 （2）表示时间时，应使用半角冒号（:）。\n1 例句：早上 8:00 省略号 （1）省略号（⋯⋯）表示语句未完、或者语气的不连续。\n（2）省略号占两个汉字空间、包含六个省略点，不要使用。。。或...等非标准形式。\n（3）省略号不应与“等”这个词一起使用。\n1 2 3 4 5 错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。 正确：我们为会餐准备了各色水果，有香蕉、苹果、梨⋯⋯ 正确：我们为会餐准备了香蕉、苹果、梨等各色水果。 感叹号 （1）应该使用平静的语气叙述，尽量避免使用感叹号（！）。\n（2）不得多个感叹号连用，比如！！和!!!。\n破折号 （1）破折号————一般用于进一步解释。\n（2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。\n1 2 3 例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。 例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。 连接号 （1）连接号用于连接两个类似的词。\n（2）以下场合应该使用直线连接号（-），占一个半角字符的位置。\n两个名词的复合 图表编号 1 2 3 例句：氧化-还原反应 例句：图 1-1 （3）数值范围（例如日期、时间或数字）应该使用波浪连接号（～）或一字号（—），占一个全角字符的位置。\n1 例句：2009 年～2011 年 注意，波浪连接号前后两个值都建议加上单位。\n（4）波浪连接号也可以用汉字“至”代替。\n1 例句：周围温度：-20 °C 至 -10 °C 文档体系 结构 软件手册是一部完整的书，建议采用下面的结构。\n简介（Introduction）：[必备] [文件] 提供对产品和文档本身的总体的、扼要的说明 快速上手（Getting Started）：[可选] [文件] 如何最快速地使用产品 入门篇（Basics）：[必备] [目录] 又称“使用篇”，提供初级的使用教程 环境准备（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件 安装（Installation）：[可选] [文件] 软件的安装方法 设置（Configuration）：[必备] [文件] 软件的设置 进阶篇（Advanced）：[可选] [目录] 又称“开发篇”，提供中高级的开发教程 API（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍 FAQ：[可选] [文件] 常见问题解答 附录（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容 Glossary：[可选] [文件] 名词解释 Recipes：[可选] [文件] 最佳实践 Troubleshooting：[可选] [文件] 故障处理 ChangeLog：[可选] [文件] 版本说明 Feedback：[可选] [文件] 反馈方式 下面是两个真实范例，可参考。\nRedux 手册 Atom 手册 文件名 文档的文件名不得含有空格。\n文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。\n1 2 3 错误：名词解释.md 正确：glossary.md 文件名建议只使用小写字母，不使用大写字母。\n1 2 3 错误：TroubleShooting.md 正确：troubleshooting.md 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。\n文件名包含多个单词时，单词之间建议使用半角的连词线（-）分隔。\n1 2 3 不佳：advanced_usage.md 正确：advanced-usage.md 声明 本文档整理于阮一峰的中文技术文档排版指南。\n","date":"2023-09-03T11:45:21+08:00","image":"https://ifcat.github.io/p/%E4%B8%AD%E6%96%87%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/cover_hu90219446d80d749710387d3680557fc5_2213423_120x120_fill_q75_box_smart1.jpg","permalink":"https://ifcat.github.io/p/%E4%B8%AD%E6%96%87%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/","title":"中文技术文档排版指南"}]